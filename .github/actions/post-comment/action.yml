name: "Post Results Comment"
description: "Post formatted results comment on PR"

inputs:
  overall_score:
    description: "Overall score"
    required: true
  test_score:
    description: "Test score"
    required: true
  sonar_score:
    description: "SonarCloud score"
    required: true
  sonar_url:
    description: "SonarCloud URL"
    required: true
  security_score:
    description: "Security score"
    required: true
  frontend_score:
    description: "Frontend score"
    required: true
  team_score:
    description: "Team score"
    required: true
  ai_score:
    description: "AI score"
    required: true
  detected_stack:
    description: "Detected technology stack"
    required: true
  pr_number:
    description: "PR number"
    required: true
  team_name:
    description: "Team name"
    required: true
  high_severity:
    description: "Number of high severity security vulnerabilities"
    required: false
    default: "0"
  medium_severity:
    description: "Number of medium severity security vulnerabilities"
    required: false
    default: "0"
  low_severity:
    description: "Number of low severity security vulnerabilities"
    required: false
    default: "0"
  coverage_percentage:
    description: "Test coverage percentage"
    required: false
    default: "0"
  test_files:
    description: "Number of test files"
    required: false
    default: "0"
  sonar_status:
    description: "SonarCloud quality gate status"
    required: false
    default: "UNKNOWN"
  vulnerability_summary:
    description: "Summary of security vulnerabilities"
    required: false
    default: ""
  security_issues:
    description: "Detailed security issues found"
    required: false
    default: ""
  coverage_details:
    description: "Detailed coverage analysis"
    required: false
    default: ""
  missing_tests:
    description: "Areas missing test coverage"
    required: false
    default: ""
  quality_issues:
    description: "Summary of code quality issues"
    required: false
    default: ""
  code_smells:
    description: "Number of code smells"
    required: false
    default: "0"
  bugs:
    description: "Number of bugs"
    required: false
    default: "0"
  vulnerabilities:
    description: "Number of vulnerabilities from SonarCloud"
    required: false
    default: "0"

runs:
  using: "composite"
  steps:
    - name: ğŸ’¬ Post Analysis Results
      uses: actions/github-script@v7
      with:
        script: |
          const overall_score = parseInt('${{ inputs.overall_score }}');
          const test_score = parseInt('${{ inputs.test_score }}');
          const sonar_score = parseInt('${{ inputs.sonar_score }}');
          const security_score = parseInt('${{ inputs.security_score }}');
          const frontend_score = parseInt('${{ inputs.frontend_score }}');
          const team_score = parseInt('${{ inputs.team_score }}');
          const ai_score = parseInt('${{ inputs.ai_score }}');

          // Parse detailed analysis data
          const high_severity = parseInt('${{ inputs.high_severity }}');
          const medium_severity = parseInt('${{ inputs.medium_severity }}');
          const low_severity = parseInt('${{ inputs.low_severity }}');
          const coverage_percentage = parseFloat('${{ inputs.coverage_percentage }}');
          const test_files = parseInt('${{ inputs.test_files }}');
          const sonar_status = '${{ inputs.sonar_status }}';
          const code_smells = parseInt('${{ inputs.code_smells }}');
          const bugs = parseInt('${{ inputs.bugs }}');
          const vulnerabilities = parseInt('${{ inputs.vulnerabilities }}');

          // Parse detailed descriptions (replacing | with newlines for multi-line content)
          const vulnerability_summary = ('${{ inputs.vulnerability_summary }}' || '').replace(/\|/g, '\n');
          const security_issues = ('${{ inputs.security_issues }}' || '').replace(/\|/g, '\n');
          const coverage_details = ('${{ inputs.coverage_details }}' || '').replace(/\|/g, '\n');
          const missing_tests = ('${{ inputs.missing_tests }}' || '').replace(/\|/g, '\n');
          const quality_issues = ('${{ inputs.quality_issues }}' || '').replace(/\|/g, '\n');

          // Total vulnerabilities
          const total_vulnerabilities = high_severity + medium_severity + low_severity;

          // Helper function to create progress bar
          function createProgressBar(score) {
            const filledBlocks = Math.floor(score / 10);
            const emptyBlocks = 10 - filledBlocks;
            return 'â–ˆ'.repeat(filledBlocks) + 'â–‘'.repeat(emptyBlocks);
          }

          // Helper function to get grade emoji
          function getGradeEmoji(score) {
            if (score >= 90) return 'ğŸ†';
            if (score >= 80) return 'ğŸ¥‡';
            if (score >= 70) return 'ğŸ¥ˆ';
            if (score >= 60) return 'ğŸ¥‰';
            return 'ğŸ”§';
          }          // Helper function to get status emoji
          function getStatusEmoji(score) {
            if (score >= 80) return 'âœ…';
            if (score >= 60) return 'âš ï¸';
            return 'âŒ';
          }

          // Helper function to parse and format specific issues
          function parseIssues(issuesText, maxCount = 5) {
            if (!issuesText || issuesText.trim() === '') return [];
            
            const lines = issuesText.split('\n').filter(line => line.trim() !== '');
            const issues = [];
            
            for (const line of lines.slice(0, maxCount)) {
              const trimmed = line.trim();
              if (trimmed && !trimmed.startsWith('#') && !trimmed.startsWith('==')) {
                issues.push('â€¢ ' + trimmed);
              }
            }
            
            return issues;
          }

          // Helper function to format security issues with severity
          function formatSecurityIssues(securityText, vulnerabilityText, maxCount = 5) {
            const issues = [];
            
            // Parse security_issues first
            if (securityText && securityText.trim() !== '') {
              const securityLines = securityText.split('\n').filter(line => line.trim() !== '');
              for (const line of securityLines.slice(0, maxCount)) {
                const trimmed = line.trim();
                if (trimmed && !trimmed.startsWith('#') && !trimmed.startsWith('==')) {
                  issues.push('ğŸ”´ ' + trimmed);
                }
              }
            }
            
            // Add vulnerability summary if we need more items
            if (issues.length < maxCount && vulnerabilityText && vulnerabilityText.trim() !== '') {
              const vulnLines = vulnerabilityText.split('\n').filter(line => line.trim() !== '');
              for (const line of vulnLines.slice(0, maxCount - issues.length)) {
                const trimmed = line.trim();
                if (trimmed && !trimmed.startsWith('#') && !trimmed.startsWith('==')) {
                  issues.push('âš ï¸ ' + trimmed);
                }
              }
            }
            
            return issues;
          }

          const comment = [
            '## ğŸ† Hackathon Analysis Results',
            '',
            '**Team:** ${{ inputs.team_name }}',
            '**Technology Stack:** ${{ inputs.detected_stack }}',
            '**Overall Score:** ' + getGradeEmoji(overall_score) + ' **' + overall_score + '/100**',
            '',
            '### ğŸ“Š Detailed Breakdown',
            '',
            '| Category | Score | Progress | Weight |',
            '|----------|-------|----------|---------|',
            '| ' + getStatusEmoji(test_score) + ' **Tests & Coverage** | ' + test_score + '/100 | `' + createProgressBar(test_score) + '` | 25% |',
            '| ' + getStatusEmoji(sonar_score) + ' **Code Quality** | ' + sonar_score + '/100 | `' + createProgressBar(sonar_score) + '` | 30% |',
            '| ' + getStatusEmoji(security_score) + ' **Security** | ' + security_score + '/100 | `' + createProgressBar(security_score) + '` | 20% |',
            '| ' + getStatusEmoji(frontend_score) + ' **Frontend UX** | ' + frontend_score + '/100 | `' + createProgressBar(frontend_score) + '` | 10% |',
            '| ' + getStatusEmoji(team_score) + ' **Team Collaboration** | ' + team_score + '/100 | `' + createProgressBar(team_score) + '` | 10% |',
            '| ' + getStatusEmoji(ai_score) + ' **AI Attribution** | ' + ai_score + '/100 | `' + createProgressBar(ai_score) + '` | 5% |',
            '',
            '### ğŸ” Analysis Links',
            '- ğŸ”— **[SonarCloud Report](${{ inputs.sonar_url }})** - Detailed code quality analysis',
            '- ğŸ“Š **[Full Analysis Logs](https://github.com/' + context.repo.owner + '/' + context.repo.repo + '/actions/runs/' + context.runId + ')** - Complete CI results',
            '',            '### ğŸ”’ Security Analysis'
          ];

          if (total_vulnerabilities > 0) {
            comment.push('**Summary:** ' + high_severity + ' High | ' + medium_severity + ' Medium | ' + low_severity + ' Low severity issues');
            comment.push('');
            
            // Display specific security issues found
            const specificSecurityIssues = formatSecurityIssues(security_issues, vulnerability_summary, 5);
            if (specificSecurityIssues.length > 0) {
              comment.push('**ğŸ” Top 5 Security Issues Found:**');
              for (const issue of specificSecurityIssues) {
                comment.push(issue);
              }
              comment.push('');
            } else {
              comment.push('**Details:** Review security scan logs for specific vulnerability information.');
              comment.push('');
            }
          } else {
            comment.push('âœ… **No security vulnerabilities detected!**');
            comment.push('ğŸ›¡ï¸ Your code appears to be secure from automated security scans.');
            comment.push('');
          }          comment.push('### ğŸ§ª Test Coverage Analysis');
          if (test_files > 0) {
            comment.push('**Coverage:** ' + coverage_percentage.toFixed(1) + '% | **Test Files:** ' + test_files);
            comment.push('');
            
            // Display specific coverage details
            const specificCoverageIssues = parseIssues(coverage_details, 5);
            if (specificCoverageIssues.length > 0) {
              comment.push('**ğŸ“Š Top 5 Coverage Details:**');
              for (const issue of specificCoverageIssues) {
                comment.push(issue);
              }
              comment.push('');
            }
            
            // Display specific missing test areas
            const specificMissingTests = parseIssues(missing_tests, 5);
            if (specificMissingTests.length > 0) {
              comment.push('**ğŸ¯ Top 5 Areas Needing Tests:**');
              for (const issue of specificMissingTests) {
                comment.push('ğŸ”´ ' + issue.substring(2)); // Remove the bullet and add red circle
              }
              comment.push('');
            }
          } else {
            comment.push('âš ï¸ **No test files found** - Add automated testing to improve code reliability.');
            comment.push('ğŸ“ Consider adding unit tests, integration tests, and end-to-end tests.');
            comment.push('');
          }          comment.push('### ğŸ”§ Code Quality Analysis');
          if (sonar_status !== 'UNKNOWN') {
            const gateStatus = sonar_status === 'FAILED' ? 'âŒ FAILED' : 'âœ… PASSED';
            comment.push('**Quality Gate:** ' + gateStatus);
            comment.push('**Issues Found:** ' + bugs + ' Bugs | ' + code_smells + ' Code Smells | ' + vulnerabilities + ' Vulnerabilities');
            comment.push('');
            
            // Display specific quality issues
            const specificQualityIssues = parseIssues(quality_issues, 5);
            if (specificQualityIssues.length > 0) {
              comment.push('**ğŸ” Top 5 Code Quality Issues:**');
              for (const issue of specificQualityIssues) {
                comment.push('ğŸŸ¡ ' + issue.substring(2)); // Replace bullet with yellow circle
              }
              comment.push('');
            } else if (bugs > 0 || code_smells > 0 || vulnerabilities > 0) {
              comment.push('**ğŸ”— [View detailed issues in SonarCloud](${{ inputs.sonar_url }})**');
              comment.push('');
            }
          } else {
            comment.push('â³ **SonarCloud analysis pending or unavailable.**');
            comment.push('ğŸ”— Check the SonarCloud dashboard for detailed quality metrics.');
            comment.push('');
          }          comment.push('### ğŸ¯ Priority Action Items');
          comment.push('');

          const actionItems = [];

          // Get specific security action items from scan results
          if (total_vulnerabilities > 0) {
            const securityActions = formatSecurityIssues(security_issues, vulnerability_summary, 2);
            if (securityActions.length > 0) {
              actionItems.push('**ğŸ”’ Security:**');
              for (const action of securityActions.slice(0, 2)) {
                actionItems.push('  ' + action);
              }
            } else {
              actionItems.push('**ğŸ”’ Security:** Fix ' + total_vulnerabilities + ' vulnerabilities (' + high_severity + ' high, ' + medium_severity + ' medium, ' + low_severity + ' low)');
            }
          }

          // Get specific test coverage action items
          if (test_files === 0 || coverage_percentage < 80) {
            const testActions = parseIssues(missing_tests, 2);
            if (testActions.length > 0) {
              actionItems.push('**ğŸ§ª Testing:**');
              for (const action of testActions.slice(0, 2)) {
                actionItems.push('  ğŸ”´ Add tests for: ' + action.substring(2));
              }
            } else if (test_files === 0) {
              actionItems.push('**ğŸ§ª Testing:** Create test files and achieve basic test coverage');
            } else {
              actionItems.push('**ğŸ§ª Testing:** Increase coverage from ' + coverage_percentage.toFixed(1) + '% to 80%+');
            }
          }

          // Get specific code quality action items
          if (bugs > 0 || code_smells > 5 || sonar_status === 'FAILED') {
            const qualityActions = parseIssues(quality_issues, 2);
            if (qualityActions.length > 0) {
              actionItems.push('**ğŸ”§ Code Quality:**');
              for (const action of qualityActions.slice(0, 2)) {
                actionItems.push('  ğŸŸ¡ ' + action.substring(2));
              }
            } else {
              actionItems.push('**ğŸ”§ Code Quality:** Address ' + bugs + ' bugs and ' + code_smells + ' code smells');
            }
          }

          // Show consolidated action items or fallback recommendations
          if (actionItems.length > 0) {
            for (const item of actionItems) {
              comment.push(item);
            }
          } else {
            // High-performing team recommendations
            if (overall_score >= 85) {
              comment.push('ğŸ† **Excellent work!** Your code meets high standards. Consider:');
              comment.push('â€¢ ğŸ“Š Add monitoring and observability');
              comment.push('â€¢ ğŸš€ Implement performance optimizations');
              comment.push('â€¢ ğŸ“š Enhance documentation and examples');
              comment.push('â€¢ ğŸ”„ Set up advanced CI/CD pipelines');
              comment.push('â€¢ ğŸŒ Plan for scalability and architecture improvements');
            } else {
              comment.push('ğŸ¯ **Focus areas for improvement:**');
              if (security_score < 80) comment.push('â€¢ ğŸ”’ Strengthen security practices and vulnerability management');
              if (test_score < 80) comment.push('â€¢ ğŸ§ª Increase test coverage and add comprehensive testing');
              if (sonar_score < 80) comment.push('â€¢ ğŸ”§ Improve code quality and reduce technical debt');
              if (frontend_score < 80 && frontend_score > 0) comment.push('â€¢ ğŸ¨ Enhance user experience and frontend performance');
              if (team_score < 80) comment.push('â€¢ ğŸ‘¥ Improve collaboration and development practices');
            }
          }

          comment.push('');
          comment.push('---');
          comment.push('');
          comment.push('*ğŸ¤– Analysis completed on ' + new Date().toISOString().split('T')[0] + ' | PR #${{ inputs.pr_number }} | Powered by GitHub Actions*');

          const finalComment = comment.join('\n');

          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: finalComment
          });
